{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { scaleBand, scalePoint } from 'd3-scale';\nimport { getExtremumX as getBarExtremumX, getExtremumY as getBarExtremumY } from '../BarChart/extremums';\nimport { getExtremumX as getScatterExtremumX, getExtremumY as getScatterExtremumY } from '../ScatterChart/extremums';\nimport { getExtremumX as getLineExtremumX, getExtremumY as getLineExtremumY } from '../LineChart/extremums';\nimport { isBandScaleConfig, isPointScaleConfig } from '../models/axis';\nimport { getScale } from '../internals/getScale';\nimport { SeriesContext } from './SeriesContextProvider';\nimport { DEFAULT_X_AXIS_KEY, DEFAULT_Y_AXIS_KEY } from '../constants';\nimport { getTickNumber } from '../hooks/useTicks';\nimport { useDrawingArea } from '../hooks/useDrawingArea';\nimport { getColorScale, getOrdinalColorScale } from '../internals/colorScale';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DEFAULT_CATEGORY_GAP_RATIO = 0.2;\nconst DEFAULT_BAR_GAP_RATIO = 0.1;\n\n// TODO: those might be better placed in a distinct file\nconst xExtremumGetters = {\n  bar: getBarExtremumX,\n  scatter: getScatterExtremumX,\n  line: getLineExtremumX\n};\nconst yExtremumGetters = {\n  bar: getBarExtremumY,\n  scatter: getScatterExtremumY,\n  line: getLineExtremumY\n};\nexport const CartesianContext = /*#__PURE__*/React.createContext({\n  xAxis: {},\n  yAxis: {},\n  xAxisIds: [],\n  yAxisIds: []\n});\nif (process.env.NODE_ENV !== 'production') {\n  CartesianContext.displayName = 'CartesianContext';\n}\nfunction CartesianContextProvider(props) {\n  const {\n    xAxis: inXAxis,\n    yAxis: inYAxis,\n    dataset,\n    children\n  } = props;\n  const formattedSeries = React.useContext(SeriesContext);\n  const drawingArea = useDrawingArea();\n  const xAxis = React.useMemo(() => inXAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: x-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inXAxis, dataset]);\n  const yAxis = React.useMemo(() => inYAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: y-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inYAxis, dataset]);\n  const value = React.useMemo(() => {\n    const axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis) => {\n      const getter = getters[chartType];\n      const series = formattedSeries[chartType]?.series ?? {};\n      const [minChartTypeData, maxChartTypeData] = getter({\n        series,\n        axis,\n        isDefaultAxis\n      });\n      const [minData, maxData] = acc;\n      if (minData === null || maxData === null) {\n        return [minChartTypeData, maxChartTypeData];\n      }\n      if (minChartTypeData === null || maxChartTypeData === null) {\n        return [minData, maxData];\n      }\n      return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];\n    };\n    const getAxisExtremum = (axis, getters, isDefaultAxis) => {\n      const charTypes = Object.keys(getters);\n      return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis), [null, null]);\n    };\n    const allXAxis = [...(xAxis?.map((axis, index) => _extends({\n      id: `defaultized-x-axis-${index}`\n    }, axis)) ?? []),\n    // Allows to specify an axis with id=DEFAULT_X_AXIS_KEY\n    ...(xAxis === undefined || xAxis.findIndex(({\n      id\n    }) => id === DEFAULT_X_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_X_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedXAxis = {};\n    allXAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, xExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.left + drawingArea.width, drawingArea.left] : [drawingArea.left, drawingArea.left + drawingArea.width];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;\n        completedXAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio\n        }, axis, {\n          scale: scaleBand(axis.data, range).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedXAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, range),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedXAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    const allYAxis = [...(yAxis?.map((axis, index) => _extends({\n      id: `defaultized-y-axis-${index}`\n    }, axis)) ?? []), ...(yAxis === undefined || yAxis.findIndex(({\n      id\n    }) => id === DEFAULT_Y_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_Y_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedYAxis = {};\n    allYAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, yExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.top, drawingArea.top + drawingArea.height] : [drawingArea.top + drawingArea.height, drawingArea.top];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        completedYAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio: 0\n        }, axis, {\n          scale: scaleBand(axis.data, [range[1], range[0]]).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedYAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, [range[1], range[0]]),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedYAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    return {\n      xAxis: completedXAxis,\n      yAxis: completedYAxis,\n      xAxisIds: allXAxis.map(({\n        id\n      }) => id),\n      yAxisIds: allYAxis.map(({\n        id\n      }) => id)\n    };\n  }, [drawingArea.height, drawingArea.left, drawingArea.top, drawingArea.width, formattedSeries, xAxis, yAxis]);\n\n  // @ts-ignore\n  return /*#__PURE__*/_jsx(CartesianContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nexport { CartesianContextProvider };","map":{"version":3,"names":["_extends","React","scaleBand","scalePoint","getExtremumX","getBarExtremumX","getExtremumY","getBarExtremumY","getScatterExtremumX","getScatterExtremumY","getLineExtremumX","getLineExtremumY","isBandScaleConfig","isPointScaleConfig","getScale","SeriesContext","DEFAULT_X_AXIS_KEY","DEFAULT_Y_AXIS_KEY","getTickNumber","useDrawingArea","getColorScale","getOrdinalColorScale","jsx","_jsx","DEFAULT_CATEGORY_GAP_RATIO","DEFAULT_BAR_GAP_RATIO","xExtremumGetters","bar","scatter","line","yExtremumGetters","CartesianContext","createContext","xAxis","yAxis","xAxisIds","yAxisIds","process","env","NODE_ENV","displayName","CartesianContextProvider","props","inXAxis","inYAxis","dataset","children","formattedSeries","useContext","drawingArea","useMemo","map","axisConfig","dataKey","undefined","data","Error","d","value","axisExtremumCallback","acc","chartType","axis","getters","isDefaultAxis","getter","series","minChartTypeData","maxChartTypeData","minData","maxData","Math","min","max","getAxisExtremum","charTypes","Object","keys","reduce","charType","allXAxis","index","id","findIndex","scaleType","completedXAxis","forEach","axisIndex","range","reverse","left","width","categoryGapRatio","barGapRatio","scale","paddingInner","paddingOuter","tickNumber","length","colorScale","colorMap","type","values","extremums","domain","niceScale","nice","niceDomain","allYAxis","completedYAxis","top","height","Provider"],"sources":["/Users/evewang/Desktop/Passion Project/GitHubVisualization/client/node_modules/@mui/x-charts/esm/context/CartesianContextProvider.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { scaleBand, scalePoint } from 'd3-scale';\nimport { getExtremumX as getBarExtremumX, getExtremumY as getBarExtremumY } from '../BarChart/extremums';\nimport { getExtremumX as getScatterExtremumX, getExtremumY as getScatterExtremumY } from '../ScatterChart/extremums';\nimport { getExtremumX as getLineExtremumX, getExtremumY as getLineExtremumY } from '../LineChart/extremums';\nimport { isBandScaleConfig, isPointScaleConfig } from '../models/axis';\nimport { getScale } from '../internals/getScale';\nimport { SeriesContext } from './SeriesContextProvider';\nimport { DEFAULT_X_AXIS_KEY, DEFAULT_Y_AXIS_KEY } from '../constants';\nimport { getTickNumber } from '../hooks/useTicks';\nimport { useDrawingArea } from '../hooks/useDrawingArea';\nimport { getColorScale, getOrdinalColorScale } from '../internals/colorScale';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DEFAULT_CATEGORY_GAP_RATIO = 0.2;\nconst DEFAULT_BAR_GAP_RATIO = 0.1;\n\n// TODO: those might be better placed in a distinct file\nconst xExtremumGetters = {\n  bar: getBarExtremumX,\n  scatter: getScatterExtremumX,\n  line: getLineExtremumX\n};\nconst yExtremumGetters = {\n  bar: getBarExtremumY,\n  scatter: getScatterExtremumY,\n  line: getLineExtremumY\n};\nexport const CartesianContext = /*#__PURE__*/React.createContext({\n  xAxis: {},\n  yAxis: {},\n  xAxisIds: [],\n  yAxisIds: []\n});\nif (process.env.NODE_ENV !== 'production') {\n  CartesianContext.displayName = 'CartesianContext';\n}\nfunction CartesianContextProvider(props) {\n  const {\n    xAxis: inXAxis,\n    yAxis: inYAxis,\n    dataset,\n    children\n  } = props;\n  const formattedSeries = React.useContext(SeriesContext);\n  const drawingArea = useDrawingArea();\n  const xAxis = React.useMemo(() => inXAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: x-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inXAxis, dataset]);\n  const yAxis = React.useMemo(() => inYAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: y-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inYAxis, dataset]);\n  const value = React.useMemo(() => {\n    const axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis) => {\n      const getter = getters[chartType];\n      const series = formattedSeries[chartType]?.series ?? {};\n      const [minChartTypeData, maxChartTypeData] = getter({\n        series,\n        axis,\n        isDefaultAxis\n      });\n      const [minData, maxData] = acc;\n      if (minData === null || maxData === null) {\n        return [minChartTypeData, maxChartTypeData];\n      }\n      if (minChartTypeData === null || maxChartTypeData === null) {\n        return [minData, maxData];\n      }\n      return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];\n    };\n    const getAxisExtremum = (axis, getters, isDefaultAxis) => {\n      const charTypes = Object.keys(getters);\n      return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis), [null, null]);\n    };\n    const allXAxis = [...(xAxis?.map((axis, index) => _extends({\n      id: `defaultized-x-axis-${index}`\n    }, axis)) ?? []),\n    // Allows to specify an axis with id=DEFAULT_X_AXIS_KEY\n    ...(xAxis === undefined || xAxis.findIndex(({\n      id\n    }) => id === DEFAULT_X_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_X_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedXAxis = {};\n    allXAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, xExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.left + drawingArea.width, drawingArea.left] : [drawingArea.left, drawingArea.left + drawingArea.width];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;\n        completedXAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio\n        }, axis, {\n          scale: scaleBand(axis.data, range).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedXAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, range),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedXAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    const allYAxis = [...(yAxis?.map((axis, index) => _extends({\n      id: `defaultized-y-axis-${index}`\n    }, axis)) ?? []), ...(yAxis === undefined || yAxis.findIndex(({\n      id\n    }) => id === DEFAULT_Y_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_Y_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedYAxis = {};\n    allYAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, yExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.top, drawingArea.top + drawingArea.height] : [drawingArea.top + drawingArea.height, drawingArea.top];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        completedYAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio: 0\n        }, axis, {\n          scale: scaleBand(axis.data, [range[1], range[0]]).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedYAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, [range[1], range[0]]),\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedYAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber,\n        colorScale: axis.colorMap && getColorScale(axis.colorMap)\n      });\n    });\n    return {\n      xAxis: completedXAxis,\n      yAxis: completedYAxis,\n      xAxisIds: allXAxis.map(({\n        id\n      }) => id),\n      yAxisIds: allYAxis.map(({\n        id\n      }) => id)\n    };\n  }, [drawingArea.height, drawingArea.left, drawingArea.top, drawingArea.width, formattedSeries, xAxis, yAxis]);\n\n  // @ts-ignore\n  return /*#__PURE__*/_jsx(CartesianContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nexport { CartesianContextProvider };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}